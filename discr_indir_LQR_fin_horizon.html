<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>B(E)3M35ORR – Optimal and Robust Control – Discrete-time LQR on a finite horizon</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./discr_indir_LQR_inf_horizon.html" rel="next">
<link href="./discr_indir_general.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./discr_indir_general.html">4. Discrete-time optimal control – indirect approach</a></li><li class="breadcrumb-item"><a href="./discr_indir_LQR_fin_horizon.html">Discrete-time LQR on a finite horizon</a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">B(E)3M35ORR – Optimal and Robust Control</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">1. Optimization – theory</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./opt_theory_problems.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Optimization problems</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./opt_theory_reformulations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Problem reformulations</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./opt_theory_unconstrained.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Theory for unconstrained optimization</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./opt_theory_constrained.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Theory for constrained optimization</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./opt_theory_modellers.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Optimization modelling languages</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./opt_theory_references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References for optimization theory</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">2. Optimization – algorithms</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./opt_algo_derivatives.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Computing derivatives</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./opt_algo_unconstrained.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Algorithms for unconstrained optimization</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./opt_algo_constrained.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Algorithms for constrained optimization</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./opt_algo_solvers.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Numerical solvers</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./opt_algo_references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References for optimization algorithms</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">
 <span class="menu-text">3. Discrete-time optimal control – direct approach</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./discr_dir_general.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">General finite-horizon nonlinear discrete-time optimal control as nonlinear program</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./discr_dir_LQR.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Finite-horizon LQR-optimal control as QP</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./discr_dir_mpc.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Model predictive control (MPC)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./discr_dir_mpc_solvers.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Numerical solvers for MPC</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./discr_dir_references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References for direct approach to discrete-time optimal control</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true">
 <span class="menu-text">4. Discrete-time optimal control – indirect approach</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./discr_indir_general.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">General nonlinear discrete-time optimal control</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./discr_indir_LQR_fin_horizon.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Discrete-time LQR on a finite horizon</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./discr_indir_LQR_inf_horizon.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Discrete-time LQR-optimal control on an infinite horizon</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./discr_indir_DARE.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Discrete-time algebraic Riccati equation (DARE)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./discr_indir_references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References for indirect approach to discrete-time optimal control</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="true">
 <span class="menu-text">5. Discrete-time optimal control – dynamic programming</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./dynamic_programming.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Optimal control via dynamic programming</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./dynamic_programming_LQR.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">LQR via dynamic programming</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" aria-expanded="true">
 <span class="menu-text">6. More on MPC</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./discr_dir_mpc_stability.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Stability of MPC</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./discr_dir_mpc_recursive_feasibility.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Recursive feasibility</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./discr_dir_mpc_explicit.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Explicit MPC</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./discr_dir_mpc_economic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Economic MPC</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" aria-expanded="true">
 <span class="menu-text">7. Continuous-time optimal control - indirect approach via calculus of variations</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-7" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cont_indir_calculus_of_variations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Calculus of variations and optimal control</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cont_indir_via_calculus_of_variations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Indirect approach to optimal control</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cont_indir_LQR_fin_horizon.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Indirect approach to LQR on a finite horizon</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cont_indir_LQR_inf_horizon.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Indirect approach to LQR on an infinite horizon</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cont_indir_CARE.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Continuous-time Riccati equation</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" aria-expanded="true">
 <span class="menu-text">8. Continuous-time optimal control - indirect approach via Pontryagin’s maximum principle</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-8" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cont_indir_Pontryagin.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Pontryagin’s maximum principle</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cont_indir_constrained.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Constrained optimal control</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cont_indir_time_optimal.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Time-optimal control</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-9" aria-expanded="true">
 <span class="menu-text">9. Continuous-time optimal control - direct approach via numerical optimization</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-9" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-9" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cont_dir_shooting.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Shooting method for optimal control</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cont_dir_multiple_shooting.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Multiple shooting method for optimal control</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cont_dir_collocation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Collocation methods for optimal control</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-10" aria-expanded="true">
 <span class="menu-text">10. Some extensions: LQG, LTR, H2</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-10" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-10" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stochastic_LQR.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Stochastic LQR control</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./LQG.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">LQG control</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./LTR.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Loop transfer recovery (LTR)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./H2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">H2-optimal control</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-11" aria-expanded="true">
 <span class="menu-text">11. Uncertainty modelling and analysis</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-11" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-11" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./uncertainty.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Uncertainty modelling</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./robustness.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Robustness analysis</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-12" aria-expanded="true">
 <span class="menu-text">12. Robust control</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-12" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-12" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./rocond_mixed_sensitivity.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Mixed sensitivity design</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./rocond_H_infinity_control.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Hinfinity-optimal control</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./rocond_mu_synthesis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Mu synthesis</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-13" aria-expanded="true">
 <span class="menu-text">13. Limits of performance</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-13" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-13" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./limits_of_performance_SISO.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Limits for SISO systems</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./limits_of_performance_MIMO.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Limits for MIMO systems</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-14" aria-expanded="true">
 <span class="menu-text">14. Model and controller order reduction</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-14" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-14" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./reduction_order_model.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Model order reduction</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./reduction_order_controller.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Controller order reduction</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#zero-input-case-and-discrete-time-algebraic-lyapunov-equation" id="toc-zero-input-case-and-discrete-time-algebraic-lyapunov-equation" class="nav-link active" data-scroll-target="#zero-input-case-and-discrete-time-algebraic-lyapunov-equation">Zero-input case and discrete-time (algebraic) Lyapunov equation</a></li>
  <li><a href="#fixed-final-state-and-finite-time-horizon" id="toc-fixed-final-state-and-finite-time-horizon" class="nav-link" data-scroll-target="#fixed-final-state-and-finite-time-horizon">Fixed final state and finite time horizon</a>
  <ul class="collapse">
  <li><a href="#special-case-minimum-energy-control-mathbf-q-mathbf-0" id="toc-special-case-minimum-energy-control-mathbf-q-mathbf-0" class="nav-link" data-scroll-target="#special-case-minimum-energy-control-mathbf-q-mathbf-0">Special case: minimum-energy control (<span class="math inline">\mathbf Q = \mathbf 0</span>)</a></li>
  </ul></li>
  <li><a href="#free-final-state-and-finite-time-horizon" id="toc-free-final-state-and-finite-time-horizon" class="nav-link" data-scroll-target="#free-final-state-and-finite-time-horizon">Free final state and finite time horizon</a>
  <ul class="collapse">
  <li><a href="#second-order-sufficient-conditions" id="toc-second-order-sufficient-conditions" class="nav-link" data-scroll-target="#second-order-sufficient-conditions">Second order sufficient conditions</a></li>
  <li><a href="#numerical-example-with-a-scalar-and-first-order-system" id="toc-numerical-example-with-a-scalar-and-first-order-system" class="nav-link" data-scroll-target="#numerical-example-with-a-scalar-and-first-order-system">Numerical example with a scalar and first-order system</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/hurak/orr/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./discr_indir_general.html">4. Discrete-time optimal control – indirect approach</a></li><li class="breadcrumb-item"><a href="./discr_indir_LQR_fin_horizon.html">Discrete-time LQR on a finite horizon</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Discrete-time LQR on a finite horizon</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>We consider a linear time-invariant (LTI) system described by the state equation <span class="math display">
\bm x_{k+1} = \mathbf A \bm x_{k} + \mathbf B \bm u_k, \qquad \bm x_0 = \mathbf x_0,
</span> and our goal is to find a (vector) control sequence <span class="math inline">\bm u_0, \bm u_{1},\ldots, \bm u_{N-1}</span> that minimizes <span class="math display">
J_0^N = \frac{1}{2}\bm x_N^\top\mathbf S_N\bm x_N + \frac{1}{2}\sum_{k=0}^{N-1}\left[\bm x_k^\top \mathbf Q \bm x_k+\bm u_k^\top \mathbf R\bm u_k\right],
</span> where the quadratic cost function is parameterized the matrices that must be symmetric and at least positive semidefinite, otherwise the corresponding quadratic terms will not play a good role of penalizing the (weighted) distance from zero.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Regulation vs tracking
</div>
</div>
<div class="callout-body-container callout-body">
<p>Indeed, with the current setup our goal is to bring the state to zero and keep the control effort as small as possible. This control problem is called <em>regulation</em>. Later we are going to extend this into the problem of <em>tracking</em> a nonzero reference state (or even output, after adding the output variables into the game) trajectory.</p>
</div>
</div>
<p>We will see in a moment that the matrix <span class="math inline">\mathbf R</span> must comply with an even stricter condition – it must be positive definite. To summarize the assumptions about the matrices, we require <span class="math display">
\mathbf S_N\succeq 0, \mathbf Q\succeq 0, \mathbf R\succ 0.
</span></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Time-invariant systems can start at time zero
</div>
</div>
<div class="callout-body-container callout-body">
<p>For time-invariant systems we can set the initial time to zero, that is, <span class="math inline">i=0</span>, without loss of generality.</p>
</div>
</div>
<p>The Hamiltonian for our problem is <span class="math display">
\boxed{
H(\bm x_k, \bm u_k, \bm \lambda_{k+1}) = \frac{1}{2}\left(\bm x_k^\top \mathbf Q\bm x_k+\bm u_k^\top \mathbf R\bm u_k\right) + \boldsymbol \lambda_{k+1}^\top\left(\mathbf A\bm x_k+\mathbf B\bm u_k\right).
}
</span></p>
<p>In the following derivations we use the shorthand notation <span class="math inline">H_k</span> for <span class="math inline">H(\bm x_k, \bm u_k, \bm \lambda_{k+1})</span>.</p>
<p>Substituting into the general necessary conditions derived in the previous section we obtain <span class="math display">
\begin{aligned}
\mathbf x_{k+1} &amp;= \nabla_{\boldsymbol \lambda_{k+1}}H_k=\mathbf A\bm x_k+\mathbf B\bm u_k,\\
\boldsymbol\lambda_k &amp;= \nabla_{\mathbf x_{k}}H_k=\mathbf Q\bm x_k+\mathbf A^\top\boldsymbol\lambda_{k+1},\\
\mathbf 0 &amp;= \nabla_{\mathbf u_{k}}H_k = \mathbf R\bm u_k + \mathbf B^\top\boldsymbol\lambda_{k+1},\\
0 &amp;= (\mathbf S_N \bm x_N - \boldsymbol \lambda_N)^\top\; \text{d} \bm x_N,\\
\bm x_0 &amp;= \mathbf x_0.
\end{aligned}
</span></p>
<p>The last two equations represent boundary conditions. Note that here we have already fixed the initial state. If this is not appropriate in a particular scenario, go back and adjust the boundary equation accordingly.</p>
<p>The third equation above – the stationarity equation – can be used to extract the optimal control <span class="math display">
\bm u_k = -\mathbf R^{-1}\mathbf B^\top\boldsymbol\lambda_{k+1}.
</span></p>
<p>The need for nonsingularity of <span class="math inline">\mathbf R</span> is now obvious. Upon substituting the recipe for the optimal <span class="math inline">\bm u_k</span> into the state and the co-state equations, two recursive (or recurrent or just discrete-time) equations result <span class="math display">
\begin{bmatrix}
\mathbf x_{k+1}\\\boldsymbol\lambda_k
\end{bmatrix}
=
\begin{bmatrix}
\mathbf A &amp; -\mathbf B\mathbf R^{-1}\mathbf B^\top\\\mathbf Q &amp; \mathbf A^\top
\end{bmatrix}
\begin{bmatrix}
\bm x_k \\ \boldsymbol\lambda_{k+1}
\end{bmatrix}.
</span></p>
<p>This is a two-point boundary value problem (TP-BVP). The problem is of order <span class="math inline">2n</span>, where <span class="math inline">n</span> is the dimension of the state space. In order to solve it we need <span class="math inline">2n</span> boundary values: <span class="math inline">n</span> boundary values are provided by <span class="math inline">\bm x_i = \mathbf x_0</span>, and <span class="math inline">n</span> boundary values are given by the other boundary condition, from which <span class="math inline">\boldsymbol\lambda_N</span> must be extracted. Most of our subsequent discussion will revolve around this task.</p>
<p>An idea might come into our mind: provided <span class="math inline">\mathbf A</span> is nonsingular, we can left-multiply the above equation by the inverse of <span class="math inline">\mathbf A</span> to obtain <span id="eq-discrete-Hamiltonian-system"><span class="math display">
\begin{bmatrix}
\mathbf x_{k}\\\boldsymbol\lambda_k
\end{bmatrix}
=
\begin{bmatrix}
\mathbf A^{-1} &amp; \mathbf A^{-1}\mathbf B\mathbf R^{-1}\mathbf B^\top\\\mathbf Q\mathbf A^{-1} &amp; \mathbf A^\top+\mathbf Q\mathbf A^{-1}\mathbf B\mathbf R^{-1}\mathbf B^\top
\end{bmatrix}
\begin{bmatrix}
\mathbf x_{k+1} \\ \boldsymbol\lambda_{k+1}
\end{bmatrix}
\tag{1}</span></span></p>
<p>This helped at least to have both variable evolving in the same direction in time (both backward) but we do not know <span class="math inline">\boldsymbol\lambda_N</span> anyway. Nonetheless, do not forget this result. We are going to invoke it later.</p>
<section id="zero-input-case-and-discrete-time-algebraic-lyapunov-equation" class="level3">
<h3 class="anchored" data-anchor-id="zero-input-case-and-discrete-time-algebraic-lyapunov-equation">Zero-input case and discrete-time (algebraic) Lyapunov equation</h3>
<p>Before we delve into solution of the original problem, let us investigate a somewhat artificial problem when no control input is applied. We compute the cost of not controlling the system at all. This will give us some valuable insight.</p>
<p>We start by evaluating the cost of starting at the terminal time <span class="math inline">N</span> and then proceed backwards in time, that is, decrease the initial time to to <span class="math inline">N-1, N-2</span> and so on. For simplicity of notation we omit the upper index in the cost function, since the final time remains the same throughout the computation. But we do use the lower index here <span class="math display">
\begin{aligned}
J_N &amp;= \frac{1}{2}\bm x_N^\top \mathbf S_N\bm x_N\\
J_{N-1} &amp;= \frac{1}{2}\bm x_N^\top\mathbf  S_N\bm x_N + \frac{1}{2}\mathbf x_{N-1}^\top \mathbf Q_{N-1}\mathbf x_{N-1}\\
    &amp;= \frac{1}{2}\mathbf x_{N-1}^\top\left(\mathbf A^\top \mathbf S_NA+\mathbf Q\right)\mathbf x_{N-1}\\
J_{N-2} &amp;=\ldots
\end{aligned}
</span></p>
<p>Upon introducing a new name <span class="math inline">\mathbf S_{N-1}</span> for term <span class="math inline">\mathbf A^\top \mathbf S_N \mathbf A+\mathbf Q</span> and similarly for all preceding times, we arrive at a <strong>discrete-time Lyapunov equation</strong> <span class="math display">
\boxed{\mathbf S_{k} = \mathbf A^\top \mathbf S_{k+1}\mathbf A+\mathbf Q.}
</span></p>
<p>This is a very famous and well-investigated equation in systems and control theory. Its solution is given by <span class="math display">
\mathbf S_k = (\mathbf A^\top)^{N-k}\mathbf S_N\mathbf A^{N-k} + \sum_{i=k}^{N-1}\left(\mathbf A^\top \right)^{N-i-1}\mathbf Q\mathbf A^{N-i-1}.
</span></p>
<p>Having the sequence of <span class="math inline">\mathbf S_k</span> at hand, the cost function when starting at time <span class="math inline">k</span> (and finishing at time <span class="math inline">N</span>) can be readily evaluated as <span class="math display">
J_k = \frac{1}{2}\bm x_k^\top \mathbf S_k\bm x_k.
</span></p>
<p>We will come back to this observation in a few moments. Before we do that, note that if the plant is stable, the cost over <span class="math inline">[-\infty,N]</span> is finite and is given by <span class="math display">
J_{-\infty}^N = \frac{1}{2}\bm x_{-\infty}^\top \mathbf S_{-\infty} \bm x_{-\infty},
</span> or, equivalently (thanks to the fact that the system is time-invariant) – and perhaps even more conveniently – we can introduce a new time <span class="math inline">k' = N-k</span>, which then ranges over <span class="math inline">[0,\infty]</span> as <span class="math inline">k</span> goes from <span class="math inline">N</span> to <span class="math inline">-\infty</span> <span class="math display">
J_0^\infty = \frac{1}{2}\bm x_0^\top \mathbf S_\infty \bm x_0.
</span></p>
<p>Even though this result was derived for the no-control case, which is not what we are after in the course on control design, it is still useful. It gives some hint as for the structure of the cost function. Indeed, we will see later that even in the case of nonzero control, the cost will be a quadratic function of the initial state.</p>
<p>When it comes to the computation of <span class="math inline">\mathbf S_\infty</span>, besides the implementation of the limiting iterative process, we may exploit the fact that in the steady state <span class="math display">
\mathbf S_k = \mathbf S_{k+1},
</span> which turns the difference Lyapunov equation into the even more famous <strong>algebraic Lyapunov equation</strong> (ALE) <span class="math display">
\boxed{\mathbf S = \mathbf A^\top \mathbf S\mathbf A+\mathbf Q.}
</span></p>
<p>Notoriously known facts about this equation (studied in introductory courses on linear systems) are</p>
<ul>
<li>If <span class="math inline">\mathbf A</span> stable and <span class="math inline">\mathbf Q\succeq 0</span>, then there is a solution to the ALE satisfying <span class="math inline">\mathbf S\succeq 0</span>.</li>
<li>If <span class="math inline">\mathbf A</span> stable and <span class="math inline">(\mathbf A,\sqrt{\mathbf Q})</span> observable, then there is a {unique} solution to ALE satisfying <span class="math inline">\mathbf S\succ 0</span>.</li>
</ul>
<p>If the system is unstable, the cost can be finite or infinite, depending on <span class="math inline">\mathbf Q</span>. As a trivial example, for <span class="math inline">\mathbf Q=0</span>, the cost will stay finite — exactly zero — disregarding the system blowing out.</p>
<p>Concerning methods for numerical solution, ALE is just a linear equation and as such can be reformulated into the standard <span class="math inline">\mathbf A \bm x=\mathbf b</span> form (using a trick based on <em>Kronecker product</em>, see <a href="https://www.mathworks.com/help/matlab/ref/kron.html">kron</a> in Matlab). Specialized algorithms exist and some of them are implemented in <a href="https://www.mathworks.com/help/control/ref/dlyap.html">dlyap</a> function in Matlab. State-of-the-art Julia implementations are in <a href="https://github.com/andreasvarga/MatrixEquations.jl">MatrixEquations.jl</a> package.</p>
</section>
<section id="fixed-final-state-and-finite-time-horizon" class="level2">
<h2 class="anchored" data-anchor-id="fixed-final-state-and-finite-time-horizon">Fixed final state and finite time horizon</h2>
<p>Back to the nonzero control case. First we are going to investigate the scenario when the final requested state is given by <span class="math inline">\mathbf x^\text{ref}</span>. The optimal control problem turns into <span class="math display">
\begin{aligned}
\operatorname*{minimize}_{\bm x_0, \bm{x}_{1},\ldots,\bm{x}_{N},\bm{u}_{0},\ldots,\bm{u}_{N-1}} &amp;\; \frac{1}{2}\sum_{k=0}^{N-1}\left[\bm x_k^T \mathbf Q \bm x_k+\bm u_k^T \mathbf R\bm u_k\right]\\
\text{s.t. } &amp; \; \mathbf x_{k+1} = \mathbf A \mathbf x_{k} + \mathbf B \bm u_k,\\
&amp;\; \bm x_0 = \mathbf x_0,\\
&amp;\; \bm x_N = \mathbf x^\text{ref},\\
&amp;\; \mathbf Q\geq 0, \mathbf R&gt;0.
\end{aligned}
</span></p>
<div class="quarto-video ratio ratio-16x9"><iframe data-external="1" src="https://www.youtube.com/embed/lI3TpldnVW0?si=luwvea7gfPW8pvo9" title="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>
<p>Note also that the term penalizing the final state is removed from the cost because it is always fixed. After eliminating the controls using the stationarity equation <span class="math display">
\bm u_k = -\mathbf R^{-1}\mathbf B^\top\boldsymbol\lambda_{k+1},
</span> and replacing the general boundary condition at the final time by <span class="math inline">\bm x_N = \mathbf x^\text{ref}</span>, the two-point boundary value problem specializes to <span class="math display">
\begin{aligned}
\mathbf x_{k+1} &amp;=\mathbf A\bm x_k-\mathbf B\mathbf R^{-1}\mathbf B^\top\boldsymbol\lambda_{k+1},\\
\boldsymbol\lambda_k &amp;= \mathbf Q\bm x_k+\mathbf A^\top\boldsymbol\lambda_{k+1},\\
\bm x_0 &amp;= \mathbf x_0,\\
\bm x_N &amp;= \mathbf x^\text{ref}.
\end{aligned}
</span></p>
<p>This problem is clearly an instance of a two-point boundary value problem (TP-BVP) as the state vector is specified at both ends of the time interval. The costate is left unspecified, but it is fine because only <span class="math inline">2n</span> boundary conditions are needed. While BVP are generally difficult to solve, our problem at hand adds one more layer of complexity. For the state variable its evolution forward in time is specified by the state equation, while for the co-state variable the evolution backward in time is prescribed by the co-state equation.</p>
<p><span class="math display">
\begin{bmatrix}
\mathbf x_{k+1}\\\boldsymbol\lambda_k
\end{bmatrix}
=
\begin{bmatrix}
\mathbf A &amp; -\mathbf B\mathbf R^{-1}\mathbf B^\top\\\mathbf Q &amp; \mathbf A^\top
\end{bmatrix}
\begin{bmatrix}
\bm x_k \\ \boldsymbol\lambda_{k+1}.
\end{bmatrix}
</span></p>
<p>There is not much we can do with these equations in this form. However, in case of a nonsingular matrix <span class="math inline">\mathbf A</span>, we can invoke the discrete-time Hamiltonian system (<a href="#eq-discrete-Hamiltonian-system" class="quarto-xref">Equation&nbsp;1</a>), in which we reorganized the equations so that both state and co-state variables evolve backwards. For convenience we give it here again <span class="math display">
\begin{bmatrix}
\mathbf x_{k}\\\boldsymbol\lambda_k
\end{bmatrix}
=\underbrace{
\begin{bmatrix}
\mathbf A^{-1} &amp; \mathbf A^{-1}\mathbf B\mathbf R^{-1}\mathbf B^\top\\\mathbf Q\mathbf A^{-1} &amp; \mathbf A^\top+\mathbf Q\mathbf A^{-1}\mathbf B\mathbf R^{-1}\mathbf B^\top
\end{bmatrix}}_{\mathbf H}
\begin{bmatrix}
\mathbf x_{k+1} \\ \boldsymbol\lambda_{k+1}.
\end{bmatrix}
</span></p>
<p>This can be used to relate the state and costate at the initial and final times of the interval <span class="math display">
\begin{bmatrix}
\mathbf x_{0}\\\boldsymbol\lambda_0
\end{bmatrix}
=\underbrace{
\begin{bmatrix}
\mathbf A^{-1} &amp; \mathbf A^{-1}\mathbf B\mathbf R^{-1}\mathbf B^\top\\\mathbf Q\mathbf A^{-1} &amp; \mathbf A^\top+\mathbf Q\mathbf A^{-1}\mathbf B\mathbf R^{-1}\mathbf B^\top
\end{bmatrix}^N}_{\mathbf M\coloneqq \mathbf H^N}
\begin{bmatrix}
\mathbf x_{N} \\ \boldsymbol\lambda_{N}
\end{bmatrix}.
</span></p>
<p>From the first equation we can get <span class="math inline">\boldsymbol \lambda_N</span>. First, let’s rewrite it here <span class="math display">
\mathbf M_{12}\boldsymbol \lambda_N = \bm x_0-\mathbf M_{11}\bm x_N,
</span> from which (after substituting for the known initial and final states) <span class="math display">
\boldsymbol \lambda_N = \mathbf M_{12}^{-1}(\mathbf r_0-\mathbf M_{11}\mathbf r_N).
</span></p>
<p>Having the final state and the final co-state, <span class="math inline">\bm x_N</span> and <span class="math inline">\boldsymbol \lambda_N</span>, respectively, we can solve the Hamiltonian system backward to get the states and co-states on the whole time interval <span class="math inline">[0,N-1]</span>.</p>
<section id="special-case-minimum-energy-control-mathbf-q-mathbf-0" class="level3">
<h3 class="anchored" data-anchor-id="special-case-minimum-energy-control-mathbf-q-mathbf-0">Special case: minimum-energy control (<span class="math inline">\mathbf Q = \mathbf 0</span>)</h3>
<p>We can get some more insight into the problem if we further restrict the class of problems we can treat. Namely, we will assume <span class="math display">
\mathbf Q = \mathbf 0.
</span></p>
<p>This is a significant restriction, nonetheless the resulting problem is still practically reasonable. And we do not need to assume that <span class="math inline">\mathbf A</span> is nonsingular. The cost function is then <span class="math display">
J = \sum_{k=0}^N \mathbf u^\top_k\;\bm u_k = \sum_{k=0}^N \|\mathbf u\|_2^2,   
</span> which is why the problem is called the <em>minimum-energy control</em> problem. Rewriting the state and co-state equations with the new restriction <span class="math inline">\mathbf Q=\mathbf 0</span> we get <span class="math display">
\begin{aligned}
\bm x_{k+1} &amp;= \mathbf A\bm x_k - \mathbf B\mathbf R^{-1}\mathbf B^\top\boldsymbol\lambda_{k+1}\\
\boldsymbol \lambda_k &amp;= \mathbf A^\top\boldsymbol\lambda_{k+1}.
\end{aligned}
</span></p>
<p>It is obvious why we wanted to enforce the <span class="math inline">\mathbf Q=\mathbf 0</span> restriction — the co-state equation is now completely decoupled from the state equation and can be solved independently <span class="math display">
\boldsymbol \lambda_k = (\mathbf A^\top)^{N-k}\boldsymbol \lambda_N.
</span></p>
<p>Now substitute this solution of the co-state equation into the state equation <span class="math display">
\bm x_{k+1} = \mathbf A\bm x_k - \mathbf B\mathbf R^{-1}\mathbf B^\top(\mathbf A^\top)^{N-k-1}\boldsymbol \lambda_N.
</span></p>
<p>Finding a solution to the state equation is now straightforward — the second summand on the right is considered as a an “input”. The solution is then <span class="math display">
\bm x_{k} = \mathbf A^k\bm x_0 - \sum_{i=0}^{k-1}\mathbf A^{k-1-i}\mathbf B\mathbf R^{-1}\mathbf B^\top(\mathbf A^\top)^{N-i-1}\boldsymbol \lambda_N.
</span></p>
<p>The last step reveals the motivation for all the previous steps — we can now express the state at the final time, and by doing that we introduce some known quantity into the problem <span class="math display">
\bm x_{N} = \mathbf x^\text{ref}= \mathbf A^N\bm x_0 - \underbrace{\sum_{i=0}^{N-1}\mathbf A^{N-1-i}\mathbf B\mathbf R^{-1}\mathbf B^\top(\mathbf A^\top)^{N-i-1}}_{G_{0,N,R}}\boldsymbol \lambda_N.
</span></p>
<p>This enables us to calculate <span class="math inline">\boldsymbol \lambda_N</span> directly as a solution to a linear equation. To make the notation simpler, denote the sum in the expression above by <span class="math inline">\mathbf G_{0,N,R}</span> (we will discuss this particular object in a while) <span class="math display">
\boldsymbol \lambda_N = -\mathbf G^{-1}_{0,N,R}\; (\mathbf x^\text{ref}-\mathbf A^N\bm x_0).
</span></p>
<p>The rest is quite straightforward as the optimal control depends (through the stationarity equation) on the co-state <span class="math display">
\boxed{
\bm u_k = \mathbf R^{-1}\mathbf B^\top(\mathbf A^\top)^{N-k-1}\mathbf G^{-1}_{0,N,R}\; (\mathbf x^\text{ref}-\mathbf A^N\bm x_0).
}
</span></p>
<p>This is the desired formula for computation of the optimal control.</p>
<p>A few observations can be made</p>
<ul>
<li>The control is proportional to the difference <span class="math inline">(\mathbf x^\text{ref}-\mathbf A^N\bm x_0)</span>. The intuitive interpretation is that the further the requested final state is from the state into which the system would finally evolve without any control, the higher the control is needed.<br>
</li>
<li>The control is proportional to the inverse of a matrix <span class="math inline">\mathbf G_{0,N,R}</span> which is called weighted reachability Gramian. The standard result from the theory of linear dynamic systems is that nonsingularity of a reachability Gramian is equivalent to reachability of the system. More on this below.</li>
</ul>
<section id="weighted-reachability-gramian" class="level4">
<h4 class="anchored" data-anchor-id="weighted-reachability-gramian">Weighted reachability Gramian</h4>
<p>Recall (perhaps from your linear systems course) that there is a matrix called discrete-time reachability Gramian defined as <span class="math display">
\mathbf G = \sum_{k=0}^{\infty} \mathbf A^{k}\mathbf B\mathbf B^\top(\mathbf A^\top)^k
</span> and the nonsingularity of this matrix serves as a test of reachability for stable discrete-time linear systems.</p>
<p>How does this classical object relate to the object <span class="math inline">\mathbf G_{0,N,R}</span> introduced in the previous paragraph? First consider the restriction of the summation from the infinite interval <span class="math inline">[0,\infty]</span> to <span class="math inline">[0,N-1]</span>. In other words, we analyze the matrix <span class="math display">
\mathbf G_{0,N} = \sum_{k=0}^{N-1} \mathbf A^{N-1-k}\mathbf B\mathbf B^\top(\mathbf A^\top)^{N-1-k}.
</span></p>
<p>Recall that Caley-Hamilton theorem tells us that every higher power of an <span class="math inline">N\times N</span> matrix can be expressed as a linear combination of powers of 0 through <span class="math inline">N-1</span>. In other words, using higher order powers of <span class="math inline">A</span> than <span class="math inline">N-1</span> cannot increase the rank of the matrix.</p>
<p>Finally, provided <span class="math inline">\mathbf R</span> is nonsingular (hence <span class="math inline">\mathbf R^{-1}</span> is nonsingular as well), the rank of the Gramian is not changed after introducing the weight<br>
<span class="math display">
\mathbf G_{0,N,R} = \sum_{k=0}^{N-1} \mathbf A^{N-1-k}\mathbf B\mathbf R^{-1}\mathbf B^\top(\mathbf A^\top)^{N-1-k}.
</span></p>
<p>The weighted Gramian defined on a finite discrete-time horizon is invertible if and only if the (stable) system is reachable. This conclusion is quite natural: if an optimal control is to be found, first it must be guaranteed that any control can be found which brings the system from an arbitrary initial state into an arbitrary final state on a finite time interval — the very definition of reachability.</p>
<p>To summarize the whole fixed-final state case, the optimal control can be computed numerically by solving a TP-BVP. For the minimum-problem even a formula exists and there is no need for a numerical optimization solver. But the outcome is always just a sequence of controls. In this regard, the new (indirect) approach did not offer much more that what the direct approach did. Although the new insight is rewarding, it is paid for by the inability to handle constraints on the control or state variables.</p>
</section>
</section>
</section>
<section id="free-final-state-and-finite-time-horizon" class="level2">
<h2 class="anchored" data-anchor-id="free-final-state-and-finite-time-horizon">Free final state and finite time horizon</h2>
<p>The previous discussion revolved around the task of bringing the system to a given final state exactly. What if we relax this strict requirement and instead just request that the system be eventually brought to the close vicinity of the requested state? How close — this could be affected by the terminal state penalty in the cost function.</p>
<div class="quarto-video ratio ratio-16x9"><iframe data-external="1" src="https://www.youtube.com/embed/INdJDfZKCW0?si=yXu5erpqutp0CPUy" title="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>
<p>The only change with respect to the previous development is just in the boundary condition — the one at the final time. Now the final state <span class="math inline">\bm x_N</span> can also be used as a parameter for our optimization. Hence <span class="math inline">\text{d}\bm x_N\neq 0</span> and the other term in the product must vanish. We write down again the full necessary conditions including the new boundary conditions <span class="math display">
\begin{aligned}
\bm x_{k+1} &amp;=\mathbf A\bm x_k-\mathbf B\mathbf R^{-1}\mathbf B^\top\boldsymbol\lambda_{k+1},\\
\boldsymbol\lambda_k &amp;= \mathbf Q\bm x_k+\mathbf A^\top\boldsymbol\lambda_{k+1},\\
\bm u_k &amp;= -\mathbf R^{-1}\mathbf B^\top\boldsymbol\lambda_{k+1},\\
\mathbf S_N \bm x_N &amp;= \boldsymbol \lambda_N,\\
\bm x_0 &amp;= \mathbf x_0.
\end{aligned}
</span></p>
<p>We find ourselves in a pretty much similar trouble as before. The final-time boundary condition refers to the variables whose values we do not know. The solution is provided by the <em>insightful guess</em>, namely, why not trying to extend the linear relationship between the state and the co-state at the final time to all preceding discrete times? That is, we assume <span id="eq-sweep-assumption"><span class="math display">
\mathbf S_k \bm x_k = \boldsymbol \lambda_k.
\tag{2}</span></span></p>
<p>At first, we can have no idea if it works. But let’s try it and see what happens. Substitute (<a href="#eq-sweep-assumption" class="quarto-xref">Equation&nbsp;2</a>) into the state and co-state equations. We start with the state equation <span class="math display">
\bm x_{k+1} =\mathbf A\bm x_k-\mathbf B\mathbf R^{-1}\mathbf B^\top\mathbf S_{k+1}\bm x_{k+1}.
</span></p>
<p>Solving for <span class="math inline">\bm x_{k+1}</span> yields <span class="math display">
\bm x_{k+1} =(\mathbf I+\mathbf B\mathbf R^{-1}\mathbf B^\top\mathbf S_{k+1})^{-1}\mathbf A\bm x_k.
</span></p>
<p>Now perform the same substitution into the co-state equation <span class="math display">
\mathbf S_k \bm x_k = \mathbf Q\bm x_k+\mathbf A^\top\mathbf S_{k+1}\bm x_{k+1},
</span> and substitute for <span class="math inline">\bm x_{k+1}</span> from the state equation into the previous equation to get <span class="math display">
\mathbf S_k \bm x_k = \mathbf Q\bm x_k+\mathbf A^\top\mathbf S_{k+1}(\mathbf I+\mathbf B\mathbf R^{-1}\mathbf B^\top\mathbf S_{k+1})^{-1}\mathbf A\bm x_k.
</span></p>
<p>Since this equation must hold for an arbitrary <span class="math inline">\bm x_k</span>, we get an equation in the matrices <span class="math inline">\mathbf S_k</span> <span class="math display">
\boxed{
\mathbf S_k = \mathbf Q+\mathbf A^\top\mathbf S_{k+1}(\mathbf I+\mathbf B\mathbf R^{-1}\mathbf B^\top\mathbf S_{k+1})^{-1}\mathbf A.
}
</span></p>
<p>This is a superfamous equation and is called <strong>difference (or discrete-time) Riccati equation</strong>. When initialized with <span class="math inline">\mathbf S_N</span>, it generates the sequence of matrices <span class="math inline">\mathbf S_{N-1}, \mathbf S_{N-2}, \mathbf S_{N-3},\ldots</span> Indeed, a noteworthy feature of this sequence is that it is initialized at the final time and the equation prescribes how the sequence evolves backwards.</p>
<p>Once we have generated a sufficiently long sequence (down to <span class="math inline">\mathbf S_{1}</span>), the optimal control sequence <span class="math inline">\bm u_0, \bm u_1, \ldots, \bm u_{N-1}</span> is then computed using the stationary equation <span class="math display">
\bm u_k = -\mathbf R^{-1}\mathbf B^\top\boldsymbol\lambda_{k+1}=-\mathbf R^{-1}\mathbf B^\top\mathbf S_{k+1}\bm x_{k+1}.
</span></p>
<p>This suggests that the optimal control is generated using the state but the current scheme is noncausal because the control at a given time depends on the state at the next time. But turning this into a causal one is easy — just substitute the state equation for <span class="math inline">\bm x_{k+1}</span> and get <span class="math display">
\bm u_k =-\mathbf R^{-1}\mathbf B^\top\mathbf S_{k+1}(\mathbf A\bm x_{k}+\mathbf B\bm u_{k}).
</span></p>
<p>Solving this equation for <span class="math inline">\bm u_k</span> gives <span class="math display">
\bm u_k =\underbrace{(\mathbf I + \mathbf R^{-1}\mathbf B^\top\mathbf S_{k+1}\mathbf B)^{-1}\mathbf R^{-1}\mathbf B^\top\mathbf S_{k+1}\mathbf A}_{\mathbf K_k}\mathbf x_{k}.
</span></p>
<p>Mission accomplished. This is our desired control. A striking observation is that although we made no specifications as for the controller structure, the optimal control strategy turned out a feedback one! Let’s write it down explicitly <span class="math display">
\boxed{
\bm u_k =\mathbf K_k \bm x_{k}.
}
</span></p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
LQ-optimal control on a finite time horizon with a free final state is a feedback control
</div>
</div>
<div class="callout-body-container callout-body">
<p>The importance of this result can hardly be overstated – the optimal control comes in the form of a proportional state-feedback control law.</p>
</div>
</div>
<p>The feedback gain is time-varying and deserves a name after its inventor — <strong>Kalman gain</strong>. Incorporating the knowledge that <span class="math inline">R</span> is nonsingular, a minor simplification of the lengthy expression can be made <span class="math display">
\mathbf K_k = (\mathbf R + \mathbf B^\top\mathbf S_{k+1}\mathbf B)^{-1}\mathbf B^\top\mathbf S_{k+1}\mathbf A.
</span></p>
<p>Before we move on, let us elaborate a bit more on the difference Riccati equation. Invoking a popular (but hard to reliably memorize) rule for inversion of a sum of two matrices called <em>matrix inversion lemma</em>, which reads <span class="math display">
(\mathbf A_{11}^{-1}+\mathbf A_{12}\mathbf A_{22}\mathbf A_{21})^{-1} =\mathbf A_{11}-\mathbf A_{11}\mathbf A_{12}(\mathbf A_{21}\mathbf A_{11}\mathbf A_{12}+\mathbf A_{22}^{-1})^{-1}\mathbf A_{21}\mathbf A_{11},
</span> the Riccati equation can be rewritten (after multiplying the brackets out) as <span class="math display">
\boxed{
\mathbf S_k = \mathbf Q + \mathbf A^\top\mathbf S_{k+1}\mathbf A - \mathbf A^\top\mathbf S_{k+1}\mathbf B( \mathbf B^\top\mathbf S_{k+1}\mathbf B+\mathbf R)^{-1}\mathbf B^\top\mathbf S_{k+1}\mathbf A,
}
</span> which we will regard as an alternative form of difference Riccati equation.</p>
<p>Observing that the steps of the computation of the Kalman gain <span class="math inline">\mathbf K_k</span> reappear in the computation of the solution of the Riccati equation, a more efficient arrangement of the computation in every iteration step is <span class="math display">
\boxed{
\begin{aligned}
\mathbf K_k &amp;= \left(\mathbf B^\top \mathbf S_{k+1}\mathbf B+\mathbf R\right)^{-1}\mathbf B^\top \mathbf S_{k+1}\mathbf A\\
\mathbf S_k &amp;= \mathbf A^\top \mathbf S_{k+1}(\mathbf A-\mathbf B\mathbf K_k) + \mathbf Q.
\end{aligned}
}
</span></p>
<p>Finally, yet another equivalent version of Riccati equation is known as <span class="math display">
\boxed{
\mathbf S_k = (\mathbf A-\mathbf B\mathbf K_k)^\top \mathbf S_{k+1}(\mathbf A-\mathbf B\mathbf K_k) + \mathbf K_k^\top \mathbf R\mathbf K_k + \mathbf Q.
}
</span></p>
<p>Showing the equivalence can be an exercise.</p>
<section id="second-order-sufficient-conditions" class="level3">
<h3 class="anchored" data-anchor-id="second-order-sufficient-conditions">Second order sufficient conditions</h3>
<p>So far we only found a solution that satisfies the first-order necessary equation but we have been warned at the introductory lessons to optimization that such solution need not necessarily constitute an optimum (minimum in our case). In order to check this, the second derivative (Hessian, curvature matrix) must be found and checked for positive definiteness. Our strategy will be to find the value of the optimal cost first and then we will identify its second derivative with respect to <span class="math inline">\bm u_k</span>.</p>
<p>The trick to find the value of the optimal cost is from <span class="citation" data-cites="lewisOptimalControl2012">(<a href="#ref-lewisOptimalControl2012" role="doc-biblioref">Lewis, Vrabie, and Syrmo 2012</a>)</span> and it is rather technical and it may be hard to learn a general lesson from it. Nonetheless we will need the result. Therefore we swiftly go through the procedure without pretending that we are building a general competence. The trick is based on the observation that <span class="math display">
\frac{1}{2}\sum_{k=0}^{N-1}(\mathbf x^\top _{k+1}\mathbf S_{k+1} \mathbf x_{k+1} - \mathbf x^\top _{k}\mathbf S_{k} \mathbf x_{k}) = \frac{1}{2}\mathbf x^\top _{N}\mathbf S_{N} \mathbf x_{N} - \frac{1}{2}\mathbf x^\top _{0}\mathbf S_{0} \mathbf x_{0}.
</span></p>
<p>Now consider our optimization criterion and add zero to it. The value of the cost function does not change. Weird procedure, right? Observing that zero can also be expressed as the right hand side minus the left hand side in the above equation, we get <span class="math display">
J_0 = \frac{1}{2}\bm x_0^\top\mathbf S_0\bm x_0 + \frac{1}{2}\sum_{k=0}^{N-1}\left[\mathbf x^\top _{k+1}\mathbf S_{k+1} \mathbf x_{k+1}+\bm x_k^\top (\mathbf Q - \mathbf S_k) \bm x_k+\bm u_k^\top \mathbf R\bm u_k\right].
</span></p>
<p>Substituting the state equation, the cost function transforms to <span class="math display">
\begin{aligned}
J_0 &amp;= \frac{1}{2}\bm x_0^\top\mathbf S_0\bm x_0 + \frac{1}{2}\sum_{k=0}^{N-1}[\mathbf x^\top _{k}(\mathbf A^\top \mathbf S_{k+1}\mathbf A + \mathbf Q - \mathbf S_k) \mathbf x_{k}+\bm x_k^\top \mathbf A^\top \mathbf S_{k+1}\mathbf B \bm u_k\\
&amp;\qquad\qquad\qquad\qquad+\bm u_k^\top \mathbf B^\top \mathbf S_{k+1}\mathbf A \bm x_k+\bm u_k^\top (\mathbf B^\top \mathbf S_{k+1}\mathbf B + \mathbf R)\bm u_k].
\end{aligned}
</span></p>
<p>Substituting the Riccati equation () into the first term above <span class="math display">
\begin{aligned}
J_0 &amp;= \frac{1}{2}\bm x_0^\top\mathbf S_0\bm x_0 + \frac{1}{2}\sum_{k=0}^{N-1}[\mathbf x^\top _{k}(\mathbf A^\top \mathbf S_{k+1}\mathbf B( \mathbf B^\top \mathbf S_{k+1}\mathbf B+\mathbf R)^{-1}\mathbf B^\top \mathbf S_{k+1}\mathbf A) \mathbf x_{k}+\bm x_k^\top \mathbf A^\top \mathbf S_{k+1}\mathbf B \bm u_k\\
&amp;\qquad\qquad\qquad\qquad+\bm u_k^\top \mathbf B^\top \mathbf S_{k+1}\mathbf A \bm x_k+\bm u_k^\top (\mathbf B^\top \mathbf S_{k+1}\mathbf B + \mathbf R)\bm u_k].
\end{aligned}
</span></p>
<p>The time-varying Hessian with respect to the control <span class="math inline">\bm u_k</span> is <span class="math display">
\nabla_{\bm u_k}^2 J_0 = \mathbf B^\top \mathbf S_{k+1}\mathbf B + \mathbf R.
</span></p>
<p>Provided that <span class="math inline">\mathbf R\succ 0</span>, it can be seen that it is always guaranteed that <span class="math inline">\nabla_{\bm u_k}^2 J_0\succ 0</span>. To prove this it must be shown that <span class="math inline">\mathbf B^\top \mathbf S_{k+1}\mathbf B\succeq 0</span>. As usual, let us make things more intuitive by switching to the scalar case. The previous expression simplifies to <span class="math inline">b^2s_{k+1}</span>. No matter what the value of <span class="math inline">b</span> is, the square is always nonnegative. It remains to show that <span class="math inline">s_{k+1}\geq0</span> (and in the matrix case <span class="math inline">\mathbf S_{k+1}\succeq 0</span>). This can be seen from the prescription for <span class="math inline">\mathbf S_{k}</span> given by the Riccati equation using similar arguments for proving positive semidefiniteness of compound expressions.</p>
<p>To conclude, the solution to the first-order necessary conditions represented by the Riccati equation is always a minimizing solution.</p>
<p>We can work a bit more with the value of the optimal cost. Substituting the optimal control we can see (after some careful two-line work) that <span class="math display">
J_0 = \frac{1}{2}\bm x_0^\top  \mathbf S_0 \bm x_0.
</span></p>
<p>The same conclusion can be obtained for any time instant <span class="math inline">k</span> inside the interval <span class="math inline">[0,N]</span> <span class="math display">
\boxed{
J_k = \frac{1}{2}\bm x_k^\top  \mathbf S_k \bm x_k.
}
</span></p>
<p>This is a result that we have already seen in the no-control case: the optimal cost can be obtained as a quadratic function of the initial state using a matrix obtained as a solution to some iteration. We will use this result in the future derivations.</p>
</section>
<section id="numerical-example-with-a-scalar-and-first-order-system" class="level3">
<h3 class="anchored" data-anchor-id="numerical-example-with-a-scalar-and-first-order-system">Numerical example with a scalar and first-order system</h3>
<p>As usual, some practical insight can be developed by analyzing the things when restricted to the scalar case. For this, consider a first order system described by the first-order state equation <span class="math display">
x_{k+1} = ax_k + bu_k
</span> and the optimization criterion in the form <span class="math display">
J_0 = \frac{1}{2}s_N x_N^2 + \frac{1}{2}\sum_{k=0}^{N-1}\left[ q x_k^2+r u_k^2\right ].
</span></p>
<p>The scalar Riccati equation simplifies to <span class="math display">
s_k = a^2s_{k+1} - \frac{a^2b^2s_{k+1}^2}{b^2s_{k+1}+r} + q
</span> or <span class="math display">
s_k = \frac{a^2rs_{k+1}}{b^2s_{k+1}+r} + q.
</span></p>
<p>Obviously the final state is not particularly close to zero, which is the desired final value. However, increasing the <span class="math inline">s_N</span> term we can bring the system arbitrarily close, as the next simulation in Fig.~ confirms.</p>
<p>The last outputs suggests that both <span class="math inline">s_N</span> and <span class="math inline">K_k</span> stay constant for most of the control interval and only change dramatically towards the end of the control interval. This is indeed the case as highlighted in the next simulation output in Fig.~ when the control interval was stretched a bit.</p>
<p>The observation in the example poses a question of how much is lost after replacing the optimal control represented by the sequence <span class="math inline">\mathbf K_k</span> by a constant value <span class="math inline">\mathbf K</span>. A natural candidate is the steady-state value that <span class="math inline">\mathbf K_k</span> has as the beginning of the control interval, that is at <span class="math inline">k=0</span> in our case.</p>
<p>Obviously, on a finite-horizon there is not much to be investigated, the constant feedback gain is just <em>suboptimal</em>, but things are somewhat more involved as the control horizon stretches to infinity, that is, <span class="math inline">N\rightarrow \infty</span>. Note that allowing this is just a formal mathematical relaxation — now the optimization is done over the set of infinite control sequences but how fast or slow the response of our controlled system is depends on the choice of the weighting matrices. We will investigate this next.</p>



</section>
</section>

<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Back to top</a><div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-lewisOptimalControl2012" class="csl-entry" role="listitem">
Lewis, Frank L., Draguna Vrabie, and Vassilis L. Syrmo. 2012. <em>Optimal <span>Control</span></em>. 3rd ed. <span>John Wiley &amp; Sons</span>. <a href="https://lewisgroup.uta.edu/FL%20books/Lewis%20optimal%20control%203rd%20edition%202012.pdf">https://lewisgroup.uta.edu/FL%20books/Lewis%20optimal%20control%203rd%20edition%202012.pdf</a>.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/hurak\.github\.io\/orr\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./discr_indir_general.html" class="pagination-link" aria-label="General nonlinear discrete-time optimal control">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">General nonlinear discrete-time optimal control</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./discr_indir_LQR_inf_horizon.html" class="pagination-link" aria-label="Discrete-time LQR-optimal control on an infinite horizon">
        <span class="nav-page-text">Discrete-time LQR-optimal control on an infinite horizon</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright 2024, Zdeněk Hurák</p>
<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/hurak/orr/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>